/*
 * File: app/controller/WSC.js
 *
 * This file was generated by Sencha Architect version 2.2.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('WideScreenCalc.controller.WSC', {
    extend: 'Ext.Base',
    alias: 'controller.WSCalc',

    requires: [
        'WideScreenCalc.controller.Screen'
    ],
    singleton: true,

    getCenterHeightFF: function() {
        return((this.vsize / 2) + this.vhff);
    },

    getPixPerInch: function() {
        return (this.getSpyHNatPixRate() / (this.hsize * 12));
    },

    getProjAspectRatio: function() {
        return (this.HNatPixRate / this.VNatPixRate);
    },

    getAspectRatio: function() {
        return this.hsize / this.vsize;
    },

    getStackWidth: function() {
        return ((this.vsize * this.getProjAspectRatio()));
    },

    RoundNum: function(num, x) {
        return Ext.Number.toFixed(num, x);

    },

    getSpyHNatPixRate: function() {
        return (this.VNatPixRate * this.getAspectRatio());
    },

    getSpyVNatPixRate: function() {
        return this.VNatPixRate;
    },

    getSpyAspectRatio: function() {
        return this.getSpyHNatPixRate() / this.getSpyVNatPixRate();
    },

    getSpyScreenTotalPix: function() {
        return this.getSpyVNatPixRate() * this.getSpyHNatPixRate();
    },

    getSpyOpMonTotalPix: function() {
        return this.spyOpMonH * this.getSpyVNatPixRate();
    },

    getSpyTotalPix: function() {
        return this.getSpyScreenTotalPix() + this.getSpyOpMonTotalPix();
    },

    getScreenWidth: function() {
        var ret = this.vsize * (this.HNatPixRate / this.VNatPixRate);
        return ret;
    },

    getOverLapPix: function() {
        var ret = ((this.HNatPixRate * this.numprojectors) - this.getSpyHNatPixRate()) / (this.numprojectors - 1);
        return ret;
    },

    getOverlapSize: function() {
        var nonRoundedOLSize = this.getNonRoundedOLSize();
        var overLapPix = this.getOverLapPix();

        return (this.getNonRoundedOLSize() * (this.getOverLapPix() / this.HNatPixRate));

    },

    getNumberOuts: function() {
        var outs = 0;
        var i = 0;
        while (outs === 0){
            var spec = ((this.HNatPixRate*i) - this.getSpyHNatPixRate()) / i-1;
            if(spec >= 200 & spec <= 512)
            outs = i;
            // Safety: prevent loop for ever
            if(i > 100) continue;
            i++;
        }
        return outs;
    },

    getNonRoundedOLSize: function() {
        return this.vsize * this.getProjAspectRatio();

    },

    getSpyOverlap: function() {
        var spyHNat = this.getSpyHNatPixRate();
        return (((this.HNatPixRate * this.numprojectors) - this.getSpyHNatPixRate())/2);
    },

    getScreens: function() {

        var screens = [];
        var x = 0, p = 0, o = 0;
        var screenWidth = Math.round(wsCalc.getScreenWidth());
        var overlapSize = wsCalc.getOverlapSize();
        // x = left calculations, c = center calculations
        var c = (wsCalc.hsize / 2) - wsCalc.hsize;
        for ( i = 0; i < this.numprojectors; i++) {
            var scrn = new WideScreenCalc.controller.Screen();
            // left calcs
            scrn.leftLeft = x.toFixed(2);
            scrn.leftCenter = ((screenWidth / 2) + x).toFixed(2);
            scrn.leftRight = (screenWidth + x).toFixed(2);
            x = scrn.leftRight - overlapSize; //subtract overlap
            // center calcs
            scrn.centerLeft = c.toFixed(2);
            scrn.centerCenter = ((screenWidth / 2) + c).toFixed(2);
            scrn.centerRight = screenWidth + c;
            c = scrn.centerRight;

            // pixel output calcs
            scrn.startPixelOutput = p;
            scrn.endPixelOutput = p + wsCalc.HNatPixRate;
            p = scrn.endPixelOutput - overlapSize; //subtract overlap

            // pixel overlap calcs
            scrn.startPixelOverlap = wsCalc.HNatPixRate - wsCalc.getOverLapPix() + o;
            scrn.endPixelOverlap = scrn.startPixelOverlap + wsCalc.getOverLapPix();
            o = scrn.startPixelOverlap; // todo: subtract pixel overlap

            screens.push(scrn);
        }
        return screens;
    },

    convertFeet: function(decimalFeet) {
        var feet = Math.floor(decimalFeet);
        var inches = Math.round((decimalFeet - feet) * 12);
        var text = feet + "'-" + inches + '"';
        return text;
    },

    drawScreens: function(xMainOffset, yMainOffset, fxr, measureFrom) {
        function mouseMove(el, t, eOpts) {
            el.setAttributes({stroke: 'blue', "stroke-width": 3}, true);
        }

        function mouseOut(el, t, eOpts) {
            el.setAttributes({stroke: 'red', "stroke-width": 2}, true);
        }
        // move elelments to right to acomodate for the vertical center dimension text
        xMainOffset = xMainOffset + 10;
        // Screens
        var screens = wsCalc.getScreens();
        // Spyder Overlap
        //alert(screens[0].leftLeft + '; ' + screens[0].leftCenter + '; ' + screens[0].leftRight + '; ' + screens[0].centerCenter);
        var items = [];
        var textItems = [];
        var screenWidth = wsCalc.getScreenWidth();
        var screenHeight = wsCalc.vsize;
        for(var i = 0; i<screens.length; i++)
        {
            // Display logo as background
            var logo = {
                type: "image",
                src: "resources/vx3logo.png",
                height: screenHeight * fxr,
                width: screenWidth * fxr,
                x: (screens[i].leftLeft * fxr) + xMainOffset,
                y: yMainOffset
            };
            items.push(logo);

            // Draw the screens
            var item = {
                type: 'rect',
                fill: '#ffc',
                height: screenHeight * fxr,
                width: screenWidth * fxr,
                x: (screens[i].leftLeft * fxr) + xMainOffset,
                y: yMainOffset,
                opacity: 0.5,
                stroke: 'red',
                'stroke-width': 2,
                listeners: {
                    mouseover: mouseMove,
                    mouseout: mouseOut
                }       
            };
            items.push(item);
            // Construct the array of dimensions to loop through
            var dimensions = [
            [screens[i].leftLeft, screens[i].centerLeft],
            [screens[i].leftCenter, screens[i].centerCenter],
            [screens[i].leftRight, screens[i].centerRight]
            ];
            for(var x = 0; x < dimensions.length; x++)
            {
                var dim = dimensions[x][0];
                // Odd numbers offset by 55, even by 30 to stagger text
                var yOffset = yMainOffset + 45;
                if(i%2 === 0)
                yOffset = yMainOffset + 5;
                var xOffset = -20;

                // Dimension text        
                var textItem = {
                    type: 'text',
                    text: dim + '"',
                    x: (dim * fxr) + xOffset + xMainOffset + 3,
                    y: (screenHeight * fxr) + yOffset + 18,
                    fill: 'black',
                    font: '10px "Arial"',
                    rotate: {
                        degrees: 0
                    }
                };
                items.push(textItem);
                // Feet + inches
                var feetInches = wsCalc.convertFeet(dim);
                if(measureFrom == "center")
                {
                    feetInches = wsCalc.convertFeet(dimensions[x][1]);
                }
                var feetTextItem = Ext.clone(textItem);
                feetTextItem.text = feetInches;
                feetTextItem.y = feetTextItem.y + 13;
                items.push(feetTextItem);
                // Dimension lines
                var x1 = (dim * fxr) + xMainOffset;
                var y1 = (screenHeight * fxr) + yMainOffset ;
                var lineItem = {
                    type: "path",
                    path: "M" + x1 + " " + y1 + " v " + yOffset + " h 25 v 28 h -50 v -28 h 25 h -25 v 14 h 50",
                    stroke: "purple"
                };

                items.push(lineItem);
            }  
        }
        // Vertical Center Dimension line
        var cX1 = 5;
        var cY1 = ((screenHeight * fxr)/2) + yMainOffset ;
        var verticalCenterLineItem = {
            type: "path",
            path: "M0 " + cY1 + " h 15 M20 " + cY1 + " h 15 M40 " + cY1 + " h 15",
            stroke: "red"
        };
        items.push(verticalCenterLineItem);

        // Vertical Center Dimension text
        var verticalCenterTextItem = {
            type: "text",
            text: wsCalc.getCenterHeightFF().toFixed(2),
            fill: "black",
            font: "10px Arial",
            x: 0,
            y: cY1 - 10 
        };
        items.push(verticalCenterTextItem);
        var feetDim = wsCalc.convertFeet(wsCalc.getCenterHeightFF().toFixed(2));
        feetVerticalCenterDimTextItem = Ext.clone(verticalCenterTextItem);
        feetVerticalCenterDimTextItem.text = feetDim;
        feetVerticalCenterDimTextItem.y = feetVerticalCenterDimTextItem.y + 18;
        items.push(feetVerticalCenterDimTextItem);
        items.push(verticalCenterTextItem);

        // If Measure center, add centerline
        if(measureFrom === 'center')
        {
            cX1 = ((wsCalc.hsize/2) * fxr) + xMainOffset;
            cY1 = ((screenHeight * fxr)/2) + yMainOffset ;
            var CenterLineItem = {
                type: "path",
                path: "M" + cX1 + " " + cY1 + " v 25 M" + cX1 + " " + (cY1 + 30) + " v 15 M" + cX1 + " " + 
                (cY1 + 50) + " v 130",
                stroke: "blue"
            };
            items.push(CenterLineItem);
        }
        return items;

    },

    drawTitle: function(xMainOffset, yMainOffset, fxr) {
        var items = [];
        var center = (wsCalc.hsize/2) * fxr;
        var screenWidth = wsCalc.getScreenWidth();
        var screenHeight = wsCalc.vsize;

        // Dimension text        
        var textItem = {
            type: "text",
            text: titleText.getValue(),
            x: center,
            y: 10,
            fill: "black",
            font: '18px "Arial"'
        };
        items.push(textItem);
        // Location
        textItem = {
            type: "text",
            text: locationText.getValue(),
            x: center,
            y: 28,
            fill: "black",
            font: '14px "Arial"'
        };
        items.push(textItem);

        // Date
        textItem = {
            type: "text",
            text: new Date().toDateString(),
            x: center,
            y: 40,
            fill: "black",
            font: '12px "Arial"'
        };
        items.push(textItem);

        // Total Screens
        textItem = {
            type: "text",
            text: "Total Screens: " + numprojectors.getValue(),
            x: 40,
            y: 70,
            fill: "black",
            font: '12px "Arial"'
        };
        items.push(textItem);

        // Horizontal Line
        textItem = {
            type: 'path',
            path: 'M10 100 h ' + wsCalc.hsize * fxr,
            stroke: 'black',
            "stroke-width": 4
        }
        items.push(textItem);

        return items;
    }

});