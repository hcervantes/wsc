/*
 * File: app/controller/WSC.js
 *
 * This file was generated by Sencha Architect version 2.2.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('WideScreenCalc.controller.WSC', {
    extend: 'Ext.Base',
    alias: 'controller.WSCalc',

    requires: [
        'WideScreenCalc.controller.Screen'
    ],
    singleton: true,

    getCenterHeightFF: function() {
        return((this.vsize.value / 2) + this.VHFF);
    },

    getPixPerInch: function() {
        return (this.getSpyHNatPixRate() / (this.hsize * 12));
    },

    getAspectRatio: function() {
        return this.hsize / this.vsize;
    },

    getProjAspectRatio: function() {
        return (this.HNatPixRate / this.VNatPixRate);
    },

    getStackWidth: function() {
        return ((this.vsize * this.getProjAspectRatio()));
    },

    RoundNum: function(num, x) {
        return Ext.Number.toFixed(num, x);

    },

    getSpyHNatPixRate: function() {
        return (this.VNatPixRate * this.getAspectRatio());
    },

    getSpyVNatPixRate: function() {
        return this.VNatPixRate;
    },

    getSpyAspectRatio: function() {
        return this.getSpyHNatPixRate() / this.getSpyVNatPixRate();
    },

    getSpyScreenTotalPix: function() {
        return this.getSpyVNatPixRate() * this.getSpyHNatPixRate();
    },

    getSpyOpMonTotalPix: function() {
        return this.spyOpMonH * this.getSpyVNatPixRate();
    },

    getSpyTotalPix: function() {
        return this.getSpyScreenTotalPix() + this.getSpyOpMonTotalPix();
    },

    getScreenWidth: function() {
        var ret = this.vsize * (this.HNatPixRate / this.VNatPixRate);
        return ret;
    },

    getOverLapPix: function() {
        var ret = ((this.HNatPixRate * this.numprojectors) - this.getSpyHNatPixRate()) / (this.numprojectors - 1);
        return ret;
    },

    getOverlapSize: function() {
        var nonRoundedOLSize = this.getNonRoundedOLSize();
        var overLapPix = this.getOverLapPix();

        return (this.getNonRoundedOLSize() * (this.getOverLapPix() / this.HNatPixRate));

    },

    getNumberOuts: function() {
        var outs = 0;
        var i = 0;
        while (outs === 0){
            var spec = ((this.HNatPixRate*i) - this.getSpyHNatPixRate()) / i-1;
            if(spec >= 200 & spec <= 512)
            outs = i;
            // Safety: prevent loop for ever
            if(i > 100) continue;
            i++;
        }
        return outs;
    },

    getNonRoundedOLSize: function() {
        return this.vsize * this.getProjAspectRatio();

    },

    getSpyOverlap: function() {
        var spyHNat = this.getSpyHNatPixRate();
        return (((this.HNatPixRate * this.numprojectors) - this.getSpyHNatPixRate())/2);
    },

    getScreens: function() {

        var screens = [];
        var x = 0, p = 0, o = 0;
        var screenWidth = Math.round(wsCalc.getScreenWidth());
        var overlapSize = wsCalc.getOverlapSize();
        // x = left calculations, c = center calculations
        var c = (wsCalc.hsize / 2) - wsCalc.hsize;
        for ( i = 0; i < this.numprojectors; i++) {
            var scrn = new WideScreenCalc.controller.Screen();
            // left calcs
            scrn.leftLeft = x.toFixed(2);
            scrn.leftCenter = ((screenWidth / 2) + x).toFixed(2);
            scrn.leftRight = (screenWidth + x).toFixed(2);
            x = scrn.leftRight - overlapSize; //subtract overlap
            // center calcs
            scrn.centerLeft = c.toFixed(2);
            scrn.centerCenter = ((screenWidth / 2) + c).toFixed(2);
            scrn.centerRight = screenWidth + c;
            c = scrn.centerRight;

            // pixel output calcs
            scrn.startPixelOutput = p;
            scrn.endPixelOutput = p + wsCalc.HNatPixRate;
            p = scrn.endPixelOutput - overlapSize; //subtract overlap

            // pixel overlap calcs
            scrn.startPixelOverlap = wsCalc.HNatPixRate - wsCalc.getOverLapPix() + o;
            scrn.endPixelOverlap = scrn.startPixelOverlap + wsCalc.getOverLapPix();
            o = scrn.startPixelOverlap; // todo: subtract pixel overlap

            screens.push(scrn);
        }
        return screens;
    },

    convertFeet: function(decimalFeet) {
        var feet = Math.floor(decimalFeet);
        var inches = Math.round((decimalFeet - feet) * 12);
        var text = feet + "'-" + inches + '"';
        return text;
    },

    drawScreens: function(xMainOffset, yMainOffset, fxr, measureFrom) {
        function mouseMove(el, t, eOpts) {
            el.setAttributes({stroke: 'blue', "stroke-width": 3}, true);
        }

        function mouseOut(el, t, eOpts) {
            el.setAttributes({stroke: 'red', "stroke-width": 2}, true);
        }

        // Screens
        var screens = wsCalc.getScreens();
        // Spyder Overlap
        //alert(screens[0].leftLeft + '; ' + screens[0].leftCenter + '; ' + screens[0].leftRight + '; ' + screens[0].centerCenter);
        var items = [];
        var textItems = [];
        var screenWidth = wsCalc.getScreenWidth();
        var screenHeight = wsCalc.vsize;
        for(var i = 0; i<screens.length; i++)
        {
            // Display logo as background
            var logo = {
                type: "image",
                src: "resources/vx3logo.png",
                height: screenHeight * fxr,
                width: screenWidth * fxr,
                x: (screens[i].leftLeft * fxr) + xMainOffset,
                y: yMainOffset
            };
            items.push(logo);

            // Draw the screens
            var item = {
                type: 'rect',
                fill: '#ffc',
                height: screenHeight * fxr,
                width: screenWidth * fxr,
                x: (screens[i].leftLeft * fxr) + xMainOffset,
                y: yMainOffset,
                opacity: 0.5,
                stroke: 'red',
                'stroke-width': 2,
                listeners: {
                    mouseover: mouseMove,
                    mouseout: mouseOut
                }       
            };
            // Odd numbers offset by 55, even by 30 to stagger text
            var yOffset = yMainOffset + 75;
            if(i%2 === 0)
            yOffset = yMainOffset + 35;
            var xOffset = -20;
            items.push(item);
            // Left Decimal Dimension text        
            var textItem = {
                type: "text",
                text: screens[i].leftLeft + '"',
                x: (screens[i].leftLeft * fxr) + xOffset + xMainOffset,
                y: (screenHeight * fxr) + yOffset,
                fill: "green",
                font: "10px Arial",
                rotate: {
                    degrees: 270
                }
            };
            items.push(textItem);
            // Feet + inches
            var feetInches = wsCalc.convertFeet(screens[i].leftLeft);
            if(measureFrom == "center")
            {
                feetInches = wsCalc.convertFeet(screens[i].centerLeft);
            }
            var feetTextItem = Ext.clone(textItem);
            feetTextItem.text = feetInches;
            feetTextItem.x = feetTextItem.x + 18;
            items.push(feetTextItem);

            // Center dimension
            textItem = {
                type: "text",
                text: screens[i].leftCenter,
                x: (screens[i].leftCenter * fxr) + xOffset + xMainOffset,
                y: (screenHeight * fxr) + yOffset,
                fill: "green",
                font: "10px Arial",
                rotate: {
                    degrees: 270
                }
            };
            items.push(textItem);
            // Feet + inches
            feetInches = wsCalc.convertFeet(screens[i].leftCenter);
            if(measureFrom == "center")
            {
                feetInches = wsCalc.convertFeet(screens[i].centerCenter);
            }
            feetTextItem = Ext.clone(textItem);
            feetTextItem.text = feetInches;
            feetTextItem.x = feetTextItem.x + 18;
            items.push(feetTextItem);

            // Right dimension
            textItem = {
                type: "text",
                text: screens[i].leftRight,
                x: (screens[i].leftRight * fxr) + xOffset + xMainOffset,
                y: (screenHeight * fxr) + yOffset,
                fill: "green",
                font: "10px Arial",
                rotate: {
                    degrees: 270
                }
            };
            items.push(textItem);
            // Feet + inches
            feetInches = wsCalc.convertFeet(screens[i].leftRight);
            if(measureFrom == "center")
            {
                feetInches = wsCalc.convertFeet(screens[i].centerRight);
            }
            feetTextItem = Ext.clone(textItem);
            feetTextItem.text = feetInches;
            feetTextItem.x = feetTextItem.x + 18;
            items.push(feetTextItem);


            // Left Dimension lines
            var x1 = (screens[i].leftLeft * fxr) + xMainOffset;
            var y1 = (screenHeight * fxr) + yMainOffset ;
            var lineItem = {
                type: "path",
                path: "M" + x1 + " " + y1 + "v " + yOffset,
                stroke: "purple"
            };

            items.push(lineItem);

            // Center Dimension lines
            x1 = (screens[i].leftCenter * fxr) + xMainOffset;
            y1 = (screenHeight * fxr) + yMainOffset ;
            lineItem = {
                type: "path",
                path: "M" + x1 + " " + y1 + "v " + yOffset,
                stroke: "purple"
            };

            items.push(lineItem);

            // Right Dimension lines
            x1 = (screens[i].leftRight * fxr) + xMainOffset;
            y1 = (screenHeight * fxr) + yMainOffset ;
            lineItem = {
                type: "path",
                path: "M" + x1 + " " + y1 + "v " + yOffset,
                stroke: "purple"
            };

            items.push(lineItem);
        }

        return items;


    }

});